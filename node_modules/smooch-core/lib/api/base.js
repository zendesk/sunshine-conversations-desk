'use strict';

exports.__esModule = true;
exports.BaseApi = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _http = require('../utils/http');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Authentication credentials - an app token or a JWT must be provided
 * @typedef AuthCredentials
 * @type {object}
 * @property {string} [appToken] - an app token
 * @property {string} [jwt] - a JWT generated with the app secret and key id
 */

/**
 * @class BaseApi
 */

var BaseApi = exports.BaseApi = function () {
    function BaseApi(serviceUrl, authHeaders, headers) {
        _classCallCheck(this, BaseApi);

        this.serviceUrl = serviceUrl;
        this.authHeaders = authHeaders;
        this.headers = headers;

        // both are allowed unless stated otherwise
        this.allowedAuth = ['jwt', 'appToken'];
    }

    /**
     * Build an URL from fragments to call the API
     * @return {string} - an URL
     */


    BaseApi.prototype.getFullURL = function getFullURL() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var fragments = args.map(function (fragment) {
            return encodeURIComponent(fragment);
        });
        return _http.urljoin.apply(undefined, [this.serviceUrl].concat(fragments));
    };

    /**
     * Validates the headers sent to the server
     * @param  {array} allowedAuth  - an array of allowedAuth to override the ones on the instance
     * @return {object}             - the headers object passed in parameter
     */


    BaseApi.prototype.validateAuthHeaders = function validateAuthHeaders() {
        var allowedAuth = arguments.length <= 0 || arguments[0] === undefined ? this.allowedAuth : arguments[0];

        if (!allowedAuth || allowedAuth.length === 0) {
            return Promise.reject(new Error('Must at least provide one authentication method.'));
        }

        if (!this.authHeaders) {
            return Promise.reject(new Error('Must provide headers.'));
        }

        var canContainJwt = allowedAuth.indexOf('jwt') >= 0;
        var canContainToken = allowedAuth.indexOf('appToken') >= 0;

        var hasJwt = !!this.authHeaders.Authorization;
        var hasToken = !!this.authHeaders['app-token'];

        if (!canContainJwt && hasJwt) {
            return Promise.reject(new Error('Must not use JWT for authentication.'));
        }

        if (!canContainToken && hasToken) {
            return Promise.reject(new Error('Must not use an app token for authentication.'));
        }

        return Promise.resolve();
    };

    BaseApi.prototype.request = function request(method, url, data) {
        var _this = this;

        var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

        var _ref$allowedAuth = _ref.allowedAuth;
        var allowedAuth = _ref$allowedAuth === undefined ? this.allowedAuth : _ref$allowedAuth;

        return this.validateAuthHeaders(allowedAuth).then(function () {
            return (0, _http.http)(method, url, data, _this.getHeaders());
        });
    };

    /**
     * Combines authorization headers and custom headers passed in the Smooch constructor
     * returns {object} - The headers to be sent in HTTP requests
     */


    BaseApi.prototype.getHeaders = function getHeaders() {
        return _extends({}, this.headers, this.authHeaders);
    };

    return BaseApi;
}();